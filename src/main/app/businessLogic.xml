<?xml version="1.0" encoding="UTF-8"?>

<mule xmlns:batch="http://www.mulesoft.org/schema/mule/batch" xmlns:objectstore="http://www.mulesoft.org/schema/mule/objectstore"
	xmlns:tracking="http://www.mulesoft.org/schema/mule/ee/tracking" xmlns="http://www.mulesoft.org/schema/mule/core"
	xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
	xmlns:spring="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:sfdc="http://www.mulesoft.org/schema/mule/sfdc"
	xsi:schemaLocation="http://www.mulesoft.org/schema/mule/ee/tracking http://www.mulesoft.org/schema/mule/ee/tracking/current/mule-tracking-ee.xsd
http://www.mulesoft.org/schema/mule/sfdc http://www.mulesoft.org/schema/mule/sfdc/current/mule-sfdc.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-current.xsd
http://www.mulesoft.org/schema/mule/objectstore http://www.mulesoft.org/schema/mule/objectstore/current/mule-objectstore.xsd
http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/batch http://www.mulesoft.org/schema/mule/batch/current/mule-batch.xsd"
	version="EE-3.5.0">
    
    <batch:job name="businessLogicForInstanceABatch">
        <batch:threading-profile poolExhaustedAction="WAIT"/>
        <batch:process-records>
            <batch:step name="forEachContactInAGetContactInBStep">
                <batch:set-record-variable variableName="contactInSourceInstance" value="#[payload	]" doc:name="set contactInSourceInstance"/>
                <enricher source="#[payload]" target="#[recordVars['contactInTargetInstance']]" doc:name="store result in record var 'contactInTargetInstance'">
                    <sfdc:query-single config-ref="SalesforceB" query="SELECT Id, FirstName, LastName, Email, LastModifiedDate FROM Contact WHERE (Email LIKE '#[payload['Email']]')" doc:name="query contact from Salesforce B instance"/>
                </enricher>
                <logger message="Contact in source instance details: #[recordVars['contactInSourceInstance']]" level="INFO" doc:name="log contact details in source instance"/>
                <logger message="Contact in target instance details: #[recordVars['contactInTargetInstance']]" level="DEBUG" doc:name="log contact details in target instance"/>
            </batch:step>
            <batch:step name="forEachContactThatShouldBeUpsertedInB" filter-expression="#[recordVars['contactInTargetInstance'] is org.mule.transport.NullPayload ? (recordVars['contactInTargetInstance'].get('LastModifiedDate') &gt;= recordVars['contactInSourceInstance'].get('LastModifiedDate')) and !(payload.get('Id') == recordVars['contactInSourceInstance'].get('LastModifiedById')) : org.mule.transport.NullPayload]">
                <choice doc:name="Choice">
                    <when expression="#[recordVars['contactInTargetInstance'] is org.mule.transport.NullPayload]">
                        <logger message="The Contact in source instance does not exist in target instance; so, it should be created" level="INFO" doc:name="log that the contact does not exist in target instance"/>
                        <expression-component doc:name="prepare contact for creation"><![CDATA[
					recordVars['contactInSourceInstance'].remove('Id');
					recordVars['contactInSourceInstance'].remove('LastModifiedDate')
				]]></expression-component>
                    </when>
                    <otherwise>
                        <logger message="It exists a contact in the target instance with the same email as the one in source instance" level="INFO" doc:name="log that the does exist in target instance"/>
                        <expression-component doc:name="prepare the contact for update"><![CDATA[
									recordVars['contactInSourceInstance'].put('Id',recordVars['contactInTargetInstance'].get('Id'));
									recordVars['contactInSourceInstance'].remove('LastModifiedDate')
								]]></expression-component>
                    </otherwise>
                </choice>
                <batch:commit size="200" doc:name="Batch Commit">
                    <flow-ref name="upsertContactInBFlow" doc:name="call upsertContactInBFlow"/>
                </batch:commit>
            </batch:step>
        </batch:process-records>
    </batch:job>
    
    <batch:job name="businessLogicForInstanceBBatch">
        <batch:threading-profile poolExhaustedAction="WAIT"/>
        <batch:process-records>
            <batch:step name="forEachContactInBGetContactInAStep">
                <batch:set-record-variable variableName="contactInSourceInstance" value="#[payload]" doc:name="set contactInSourceInstance"/>
                <enricher source="#[payload]" target="#[recordVars['contactInTargetInstance']]" doc:name="store result in record var 'contactInTargetInstance'">
                    <sfdc:query-single config-ref="SalesforceA" query="SELECT Id, FirstName, LastName, Email, LastModifiedDate FROM Contact WHERE (Email LIKE '#[payload['Email']]')" doc:name="query contact from Salesforce A instance"/>
                </enricher>
                <logger message="Contact in source instance details: #[recordVars['contactInSourceInstance']]" level="INFO" doc:name="log contact details in source instance"/>
                <logger message="Contact in target instance details: #[recordVars['contactInTargetInstance']]" level="DEBUG" doc:name="log contact details in target instance"/>
            </batch:step>
            <batch:step name="forEachContactThatShouldBeUpsertedInA" filter-expression="#[recordVars['contactInTargetInstance'] is org.mule.transport.NullPayload ? (recordVars['contactInTargetInstance'].get('LastModifiedDate') &gt;= recordVars['contactInSourceInstance'].get('LastModifiedDate')) and !(payload.get('Id') == recordVars['contactInSourceInstance'].get('LastModifiedById')) : org.mule.transport.NullPayload]">
                <choice doc:name="Choice">
                    <when expression="#[recordVars['contactInTargetInstance'] is org.mule.transport.NullPayload]">
                        <logger message="The Contact in source instance does not exist in target instance; so, it should be created" level="INFO" doc:name="log that the contact does not exist in target instance"/>
                        <expression-component doc:name="prepare contact for creation"><![CDATA[
							recordVars['contactInSourceInstance'].remove('Id');
							recordVars['contactInSourceInstance'].remove('LastModifiedDate')
						]]></expression-component>
                    </when>
                    <otherwise>
                        <logger message="It exists a contact in the target instance with the same email as the one in source instance" level="INFO" doc:name="log that the does exist in target instance"/>
                        <expression-component doc:name="prepare the contact for update"><![CDATA[
							recordVars['contactInSourceInstance'].put('Id',recordVars['contactInTargetInstance'].get('Id'));
							recordVars['contactInSourceInstance'].remove('LastModifiedDate')
						]]></expression-component>
                    </otherwise>
                </choice>
                <batch:commit size="200" doc:name="Batch Commit">
                    <flow-ref name="upsertContactInAFlow" doc:name="call upsertContactInAFlow"/>
                </batch:commit>
            </batch:step>
        </batch:process-records>
    </batch:job>

	<flow name="mainFlow" processingStrategy="synchronous" doc:name="mainFlow">
		<expression-component doc:name="lock the poll inbound endpoints not to occur at the same time"><![CDATA[#[app.registry['PollSynchronizer'].acquireLock()]]]></expression-component>
		<logger level="INFO" message="~.~.~.~.~.~.~.~.~.~.~.~.~.~.~ Start synchronization from Salesforce instance #[sourceSystem] ~.~.~.~.~.~.~.~.~.~.~.~.~.~.~" doc:name="log to indicate that the synchronization has started" />
		<choice doc:name="Choice">
			<when expression="#[sourceSystem == 'A']">
		        <batch:execute name="businessLogicForInstanceABatch" doc:name="trigger businessLogicForInstanceABatch"/>
			</when>
			<otherwise>
		        <batch:execute name="businessLogicForInstanceBBatch" doc:name="trigger businessLogicForInstanceBBatch"/>
			</otherwise>
		</choice>
		<expression-component doc:name="unlock the poll inbound endpoints"><![CDATA[#[app.registry['PollSynchronizer'].releaseLock()]]]></expression-component>

		<exception-strategy ref="defaultChoiceExceptionStrategy" doc:name="catch Exception and call defaultChoiceExceptionStrategy" />
	</flow>
	
    <flow name="upsertContactInAFlow" doc:name="upsertContactInAFlow" processingStrategy="synchronous">
        <sfdc:upsert config-ref="SalesforceA" externalIdFieldName="Id" type="Contact" doc:name="upsert Contacts in Salesforce A instance">
            <sfdc:objects ref="#[payload]"/>
        </sfdc:upsert>
        <logger message="Upsert Salesforce response: #[payload]" level="INFO" doc:name="log upsert Salesforce response"/>
    </flow>

    <flow name="upsertContactInBFlow" doc:name="upsertContactInBFlow" processingStrategy="synchronous">
        <sfdc:upsert config-ref="SalesforceB" externalIdFieldName="Id" type="Contact" doc:name="upsert Contacts in Salesforce B instance">
            <sfdc:objects ref="#[payload]"/>
        </sfdc:upsert>
        <logger message="Upsert Salesforce response: #[payload]" level="INFO" doc:name="log upsert Salesforce response"/>
    </flow>

</mule>
